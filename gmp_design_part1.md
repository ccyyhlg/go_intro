# GMP 调度器设计 - 第一章：城主的改革手记

> **第一性原理**：为了解决“军队执行微型任务”的资源错配，我们引入了“冒险者体系”，并从“中央大厅”进化到了“分布式公会”。

## 1. 缘起：军队的困境 (The Cost of Threads)

我是这座“算力之城”的城主（操作系统/Runtime设计师）。
我有两项核心资产：
1.  **地下城入口 (CPU)**：这是唯一的价值产出地。
2.  **国库 (Memory)**：这是维持运转的资源。

### 1.1 昂贵的正规军 (Machine / Kernel Thread)
在最初的制度下，所有任务都直接由 **正规军 (M)** 去执行。
但随着城市发展，这种模式遇到了“规模墙”：

*   **极高的编制成本**：
    每扩招一名正规军，国库必须拨款 **8MB** 作为固定军饷（Stack）。
    *如果要处理 10 万个任务，就要扩招 10 万名正规军，国库会瞬间破产（OOM）。*

*   **致命的“专注诅咒” (Blocking IO)**：
    正规军不仅贵，而且**非常死板**。
    当正规军去执行一个需要等待的任务（比如“去河边打水”/ 读数据库），如果水还没来，正规军会**像雕塑一样站在原地死等**。
    *哪怕全城着火了，只要水没来，他绝不挪窝。*
    *如果 8 个正规军都在等水，整座城市就彻底停摆了（CPU 闲置）。*

*   **无法通过的审批**：
    调动正规军需要向皇室申请令牌（Syscall），手续极其繁琐，且很难大规模并发。

**困境**：我们拥有海量的任务，其中很多是需要“等待”的。如果我们只用 8 个正规军，他们很快就会全部卡在“等待”中，导致无人干活。如果我们扩招 10 万个正规军，国库又养不起。

**我们需要一种机制，既能利用正规军的强大算力，又能在“等待”时把正规军解放出来。**

---

## 2. 改革一：冒险者体系 (The Birth of Goroutine)

为了解决“任务多”但“正规军少”的矛盾，我决定实行 **“代理人制度”**。

### 2.1 新的角色：冒险者 (Goroutine / G)
*   **定义**：从民间招募的廉价劳动力。
*   **成本**：自带干粮，初始只需要 **2KB** 物资。
    *   *注：我预留了晋升机制。如果任务太难，冒险者可以申请更多物资（栈动态扩容），甚至晋升为传说级冒险者（1GB Stack）。*

### 2.2 合作模式：摆渡人机制
这是改革的核心逻辑：

1.  **身份界定**：
    *   **正规军 (M)**：拥有 **“副本通行证”** (Thread)，是唯一能通过副本大门的实体。
    *   **冒险者 (G)**：拥有 **“任务委托书”** (Code)，知道具体要干什么，但没有通行证。

2.  **运作方式**：
    *   我们维持一支极小规模的精锐正规军（比如 8 人）。
    *   正规军不再直接去砍怪，而是作为 **“摆渡人” (Carrier)**。
    *   正规军在城门口接上一名冒险者，利用自己的通行证，**把冒险者带进副本**。
    *   在副本里，正规军完全听从冒险者的指挥（执行 G 的代码）。
    *   当冒险者累了（阻塞）或任务完成，正规军立刻把他送回城，**无缝切换**带下一个冒险者进去。

**成效**：我们用 **8 个正规军** 的编制，成功驱动了 **10 万名冒险者** 的轮转。既规避了高昂的军费，又完成了海量的任务。

### 2.3 正规军的常态：治安官 (g0)
当正规军没有带冒险者下副本时，他并没有闲着，而是回归了他的本职身份 —— **治安官 (g0)**。
*   他在城内巡逻（运行调度代码 `schedule()`）。
*   他在公会大厅整理委托单。
*   他负责处理突发状况（如冒险者需要扩容物资）。

**g0 本质**：M 脱下“摆渡人”马甲后的 **本体**。他时刻维护着城市的秩序，确保冒险者体系的运转。

---

## 3. 改革二：公会的演进 (From GM to GMP)

冒险者体系建立初期，我们遇到过大麻烦。

### 3.1 失败的初版：中央大厅 (GM Model)
最初，我在城中心建了一个巨大的 **中央公会大厅 (Global Queue)**。
*   所有的委托都在这里发布。
*   所有的正规军 (M) 送完一个冒险者，都得跑回市中心接下一个。

**后果**：
*   **拥堵 (Lock Contention)**：市中心人山人海。正规军把时间都花在了“挤进大厅”排队上（抢全局锁）。
*   **效率低下**：8 支军队，有 7 支在排队，只有 1 支在干活。

### 3.2 成功的终版：分布式分会 (GMP Model)
痛定思痛，我引入了 **分会制度 (Processor / P)**。

我的核心思路是：**与其让正规军每次送完人都回大厅排队，不如让他一次性领走一批人。**

*   **P (分会/批量包)**：
    *   **定义**：P 本质上就是一个 **“本地任务包”**（容量 256 个委托）。
    *   **绑定**：每支正规军 (M) 随身携带一个 P。
    *   **无锁**：正规军 (M) 送完一个冒险者，直接从兜里的 P 拿下一个。**完全不需要回大厅排队**。

**至此，GMP 的三足鼎立之势形成：**

1.  **G (冒险者)**：代表 **任务逻辑**。轻量、灵活、海量。
2.  **M (正规军)**：代表 **执行算力**。昂贵、死板、稀缺。
3.  **P (分会)**：代表 **调度上下文**。它是连接 G 和 M 的桥梁，解决了全局锁的拥堵。

但是，新的问题也随之浮现：
*   如果 M1 的 P 里任务空了，而 M2 的 P 里任务堆积如山，怎么办？（负载不均）
*   如果 M1 被“专注诅咒”（Syscall）困住了，他兜里的 P 岂不是也废了？（资源浪费）

这些运行时出现的复杂动态问题，就是我们下一章要解决的挑战。

---

## 4. 最终图景 (The Big Picture)

经过这两轮改革，我的城市拥有了最完美的静态架构：

*   **M (军队/g0)**：持有 8MB 重装备，负责运载。他只认 P，不认 G。
*   **G (冒险者)**：自带 2KB 轻装备，负责业务。他只认 M，不认 P。
*   **P (分会)**：拥有 256 个任务槽位和本地内存 (mcache)。他是 M 的弹药库，是 G 的栖息地。

这就构成了 Go 调度器的基石。下一章，我们将让这个机器 **跑起来**。
